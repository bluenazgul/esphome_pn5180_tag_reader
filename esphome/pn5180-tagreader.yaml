substitutions:
  name: pn5180-tagreader
  PN5180_NSS: "4"      # D2 / GPIO4
  PN5180_BUSY: "16"    # D0 / GPIO16
  PN5180_RST: "5"      # D1 / GPIO5
  LED_PIN: "15"        # D8 / GPIO15
  scan_interval: 300ms
  miss_threshold: "5"

esphome:
  name: ${name}
  includes:
    - pn5180_glue.h
  libraries:
    - SPI
    - PN5180-Library=https://github.com/tueddy/PN5180-Library.git#2.3.7
  platformio_options:
    lib_ldf_mode: deep+
    extra_scripts:
      - pre:/config/esphome/fix_pn5180_spi_esp8266.py
  on_boot:
    priority: -10
    then:
      - lambda: |-
          pn5180glue::begin(${PN5180_NSS}, ${PN5180_BUSY}, ${PN5180_RST});
          pn5180glue::unlock_privacy_round();

esp8266:
  board: d1_mini

logger:
  level: INFO

api:
#your api key here

ota:
#your ota pw here

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

#light
light:
  - platform: neopixelbus
    type: GRB
    variant: WS2812
    pin: ${LED_PIN}
    num_leds: 1
    name: "${name} Status-LED"
    id: status_led
    restore_mode: ALWAYS_OFF
    effects:
      - pulse:
          name: "Pulse"
          transition_length: 1.0s
          update_interval: 1.0s

      - strobe:
          name: "Strobe Red"
          colors:
            - state: true
              brightness: 60%
              red: 100%
              green: 0%
              blue: 0%
              duration: 500ms
            - state: false
              duration: 500ms

      - random:
          name: "Random Colors"
          transition_length: 600ms
          update_interval: 1.2s

# Sensors
text_sensor:
  - platform: template
    name: "${name} Tag UID"
    id: tag_uid
  - platform: template
    name: "${name} Tag Data"
    id: tag_data
  - platform: template
    name: "${name} Privacy Unlock"
    id: privacy_unlock

binary_sensor:
  - platform: template
    name: "${name} Tag present"
    id: tag_present
    device_class: occupancy

globals:
  - id: last_uid
    type: std::string
    initial_value: '""'
  - id: tmp_uid
    type: std::string
    initial_value: '""'
  - id: miss_count
    type: int
    initial_value: '0'

# Polling
interval:
  - interval: ${scan_interval}
    then:
      # 1) Inventory (with Privacy/Logs in Glue)
      - lambda: |-
          char buf[17];
          if (pn5180glue::inventory_hex_upper(buf)) {
            id(tmp_uid) = std::string(buf);
          } else {
            id(tmp_uid).clear();
          }

      # 2) New Tag detected
      - if:
          condition:
            lambda: 'return !id(tmp_uid).empty() && id(tmp_uid) != id(last_uid);'
          then:
            - lambda: |-
                id(last_uid) = id(tmp_uid);
                id(miss_count) = 0;
            - text_sensor.template.publish: { id: tag_uid,  state: !lambda 'return id(last_uid).c_str();' }
            - text_sensor.template.publish: { id: privacy_unlock, state: !lambda 'return pn5180glue::last_unlock_method();' }
            - binary_sensor.template.publish: { id: tag_present, state: ON }
            - homeassistant.tag_scanned: !lambda 'return id(last_uid).c_str();'

            # Read full Memory
            - lambda: |-
                std::string dump;
                if (pn5180glue::read_full_memory_hex(dump)) {
                  ESP_LOGI("pn5180", "Full memory read: %u blocks Ã  %u bytes -> %u hex chars",
                           (unsigned)pn5180glue::g_num_blocks, (unsigned)pn5180glue::g_block_size, (unsigned)dump.size());
                  id(tag_data).publish_state(dump.c_str());
                } else {
                  ESP_LOGW("pn5180", "Full memory read FAILED");
                  id(tag_data).publish_state("");
                }

      # 3) Tag still in place
      - if:
          condition:
            lambda: 'return !id(tmp_uid).empty() && id(tmp_uid) == id(last_uid);'
          then:
            - lambda: 'id(miss_count) = 0;'
            - binary_sensor.template.publish: { id: tag_present, state: ON }

      # 4) read short errors
      - if:
          condition:
            lambda: 'return id(tmp_uid).empty() && id(last_uid).size() > 0 && id(miss_count) < atoi("${miss_threshold}");'
          then:
            - lambda: 'id(miss_count)++;'

      # 5) Tag removed
      - if:
          condition:
            lambda: 'return id(last_uid).size() > 0 && id(miss_count) >= atoi("${miss_threshold}");'
          then:
            - homeassistant.event:
                event: esphome.tag_removed
                data:
                  tag_id: !lambda 'return id(last_uid).c_str();'
                  device: ${name}
            - text_sensor.template.publish: { id: tag_uid,  state: "" }
            - text_sensor.template.publish: { id: tag_data, state: "" }
            - text_sensor.template.publish: { id: privacy_unlock, state: "none" }
            - binary_sensor.template.publish: { id: tag_present, state: OFF }
            - lambda: |-
                id(last_uid).clear();
                id(miss_count) = 0;
